"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1926],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var i=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,l=function(e,t){if(null==e)return{};var n,i,l={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,p=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=s(n),m=l,k=d["".concat(p,".").concat(m)]||d[m]||c[m]||a;return n?i.createElement(k,o(o({ref:t},u),{},{components:n})):i.createElement(k,o({ref:t},u))}));function k(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,o=new Array(a);o[0]=m;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[d]="string"==typeof e?e:l,o[1]=r;for(var s=2;s<a;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6176:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>k,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var i=n(7462),l=n(3366),a=(n(7294),n(3905)),o=["components"],r={title:"ESM"},p=void 0,s={unversionedId:"esm",id:"esm",title:"ESM",description:"Version 3.0.0 of @oclif/core officially supports ESM plugin development and CJS/ESM interoperability, meaning that you can have a root plugin written with CJS and your bundled plugins written in ESM or vice versa.",source:"@site/../docs/esm.md",sourceDirName:".",slug:"/esm",permalink:"/docs/esm",draft:!1,editUrl:"https://github.com/oclif/oclif.github.io/tree/docs/docs/../docs/esm.md",tags:[],version:"current",lastUpdatedBy:"Mike Donnalley",lastUpdatedAt:1693504752,formattedLastUpdatedAt:"Aug 31, 2023",frontMatter:{title:"ESM"},sidebar:"docs",previous:{title:"Single Command CLI",permalink:"/docs/single_command_cli"},next:{title:"Examples",permalink:"/docs/examples"}},u={},d=[{value:"Interoperability Overview",id:"interoperability-overview",level:2},{value:"ESM Root plugin",id:"esm-root-plugin",level:3},{value:"CJS Root plugin",id:"cjs-root-plugin",level:3},{value:"Creating an ESM plugin",id:"creating-an-esm-plugin",level:2},{value:"Migrating a CJS plugin to ESM",id:"migrating-a-cjs-plugin-to-esm",level:2},{value:"Update bin scripts",id:"update-bin-scripts",level:3},{value:"bin/dev \u2192 bin/dev.js",id:"bindev--bindevjs",level:4},{value:"bin/run \u2192 bin/run.js",id:"binrun--binrunjs",level:4},{value:"Update tsconfig.json",id:"update-tsconfigjson",level:3},{value:"Update package.json to &quot;module&quot; type",id:"update-packagejson-to-module-type",level:3},{value:"Update references to bin scripts",id:"update-references-to-bin-scripts",level:3},{value:"Update mocharc settings",id:"update-mocharc-settings",level:3},{value:"Linked Plugins",id:"linked-plugins",level:2}],c={toc:d},m="wrapper";function k(e){var t=e.components,n=(0,l.Z)(e,o);return(0,a.kt)(m,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Version ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/oclif/core/tree/3.0.0-beta.4"},"3.0.0 of ",(0,a.kt)("inlineCode",{parentName:"a"},"@oclif/core"))," officially supports ESM plugin development and CJS/ESM interoperability, meaning that you can have a root plugin written with CJS and your bundled plugins written in ESM or vice versa."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#interoperability-overview"},"Interoperability Overview"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#esm-root-plugin"},"ESM Root plugin")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#cjs-root-plugin"},"CJS Root plugin")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#creating-an-esm-plugin"},"Creating an ESM plugin")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#migrating-a-cjs-plugin-to-esm"},"Migrating a CJS plugin to ESM"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#update-bin-scripts"},"Update bin scripts"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#bindev--bindevjs"},"bin/dev \u2192 bin/dev.js")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#binrun--binrunjs"},"bin/run \u2192 bin/run.js")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#update-tsconfigjson"},"Update tsconfig.json")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#update-packagejson-to-module-type"},'Update package.json to "module" type')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#update-references-to-bin-scripts"},"Update references to bin scripts")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#update-mocharc-settings"},"Update mocharc settings")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#linked-plugins"},"Linked Plugins"))),(0,a.kt)("h2",{id:"interoperability-overview"},"Interoperability Overview"),(0,a.kt)("p",null,"Here's a high level overview of ESM/CJS interoperability:"),(0,a.kt)("h3",{id:"esm-root-plugin"},"ESM Root plugin"),(0,a.kt)("p",null,"\u2705 Install CJS plugins"),(0,a.kt)("p",null,"\u2705 Install ESM plugins"),(0,a.kt)("p",null,"\u2705 Link CJS plugins"),(0,a.kt)("p",null,"\u26a0\ufe0f Link ESM plugins"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Auto-compilation will ",(0,a.kt)("strong",{parentName:"li"},"not")," work with linked ESM plugins unless ",(0,a.kt)("inlineCode",{parentName:"li"},'NODE_OPTIONS="--loader=ts-node"')," is set in the environment. Otherwise, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. See ",(0,a.kt)("a",{parentName:"li",href:"#linked-plugins"},"linked plugins")," for more information.")),(0,a.kt)("h3",{id:"cjs-root-plugin"},"CJS Root plugin"),(0,a.kt)("p",null,"\u2705 Install CJS plugins"),(0,a.kt)("p",null,"\u2705 Install ESM plugins"),(0,a.kt)("p",null,"\u2705 Link CJS plugins"),(0,a.kt)("p",null,"\u26a0\ufe0f Link ESM plugins"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Auto-compilation will ",(0,a.kt)("strong",{parentName:"li"},"not")," work with linked ESM plugins. Instead, oclif will use the plugin's compiled source - this means that you must compile the plugin yourself before executing any of the commands. See ",(0,a.kt)("a",{parentName:"li",href:"#linked-plugins"},"linked plugins")," for more information.")),(0,a.kt)("h2",{id:"creating-an-esm-plugin"},"Creating an ESM plugin"),(0,a.kt)("p",null,"To generate a new ESM plugin from the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/oclif/hello-world-esm"},"hello-world-esm template")," run the ",(0,a.kt)("inlineCode",{parentName:"p"},"oclif generate")," command and select ",(0,a.kt)("inlineCode",{parentName:"p"},"ESM")," when it prompts you to select a module type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ npx oclif generate my-esm-plugin\n? Select a module type\n  CommonJS\n\u276f ESM\n")),(0,a.kt)("h2",{id:"migrating-a-cjs-plugin-to-esm"},"Migrating a CJS plugin to ESM"),(0,a.kt)("h3",{id:"update-bin-scripts"},"Update bin scripts"),(0,a.kt)("p",null,"First you will need to update the bin scripts under the ",(0,a.kt)("inlineCode",{parentName:"p"},"bin")," directory."),(0,a.kt)("h4",{id:"bindev--bindevjs"},"bin/dev \u2192 bin/dev.js"),(0,a.kt)("p",null,"Rename ",(0,a.kt)("inlineCode",{parentName:"p"},"bin/dev")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"bin/dev.js")," and replace the existing code with the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"#!/usr/bin/env node\n// eslint-disable-next-line node/shebang\nvoid (async () => {\n  const oclif = await import('@oclif/core')\n  await oclif.execute({development: true, dir: import.meta.url})\n})()\n")),(0,a.kt)("p",null,"This leverages oclif's ",(0,a.kt)("inlineCode",{parentName:"p"},"execute")," function which handles all the development setup for you. You no longer need set the ",(0,a.kt)("inlineCode",{parentName:"p"},"NODE_ENV")," env var or register the project with ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node"),". You still adjust oclif ",(0,a.kt)("inlineCode",{parentName:"p"},"settings")," before executing the CLI. For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"#!/usr/bin/env node\n// eslint-disable-next-line node/shebang\nvoid (async () => {\n  const oclif = await import('@oclif/core')\n  oclif.settings.performanceEnabled = true\n  await oclif.execute({type: 'esm', development: true, dir: import.meta.url})\n})()\n")),(0,a.kt)("h4",{id:"binrun--binrunjs"},"bin/run \u2192 bin/run.js"),(0,a.kt)("p",null,"Rename ",(0,a.kt)("inlineCode",{parentName:"p"},"bin/run")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"bin/run.js")," and replace the existing code with the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"#!/usr/bin/env node\nvoid (async () => {\n  const oclif = await import('@oclif/core')\n  await oclif.execute({dir: import.meta.url})\n})()\n")),(0,a.kt)("h3",{id:"update-tsconfigjson"},"Update tsconfig.json"),(0,a.kt)("p",null,"After updating the bin scripts you now need to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," to include the following options:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "module": "ES2020",\n    "moduleResolution": "node16",\n  },\n  "ts-node": {\n    "esm": true,\n    "scope": true\n  }\n}\n')),(0,a.kt)("h3",{id:"update-packagejson-to-module-type"},'Update package.json to "module" type'),(0,a.kt)("p",null,"Add ",(0,a.kt)("inlineCode",{parentName:"p"},'"type": "module"')," to your package.json so that your files will be loaded as ESM modules"),(0,a.kt)("h3",{id:"update-references-to-bin-scripts"},"Update references to bin scripts"),(0,a.kt)("p",null,"You will need to update the references to your bin scripts to the bin scripts with the ",(0,a.kt)("inlineCode",{parentName:"p"},".js")," extension. In the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," you will need to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"bin")," like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'  "bin": {\n    "my-cli": "./bin/run"\n  },\n')),(0,a.kt)("p",null,"to"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'  "bin": {\n    "my-cli": "./bin/run.js"\n  },\n')),(0,a.kt)("p",null,"You may have references to the bin scripts in your ",(0,a.kt)("inlineCode",{parentName:"p"},".vscode/launch.json"),". You'll need to update these as well."),(0,a.kt)("h3",{id:"update-mocharc-settings"},"Update mocharc settings"),(0,a.kt)("p",null,"In order for your mocha tests to run, you'll need to make a couple of changes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Add the following to the ",(0,a.kt)("inlineCode",{parentName:"li"},".mocharc.json"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "node-option": [\n    "loader=ts-node/esm"\n  ]\n}\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Update ",(0,a.kt)("inlineCode",{parentName:"li"},"test/helpers/init.js"))),(0,a.kt)("p",null,"If your plugin was generated ",(0,a.kt)("inlineCode",{parentName:"p"},"oclif generate")," then you likely have a ",(0,a.kt)("inlineCode",{parentName:"p"},"test/helpers/init.js")," file that needs to be updated. You can either update the file extension to ",(0,a.kt)("inlineCode",{parentName:"p"},".cjs")," or update the ",(0,a.kt)("inlineCode",{parentName:"p"},"require")," at the top of the file to an ",(0,a.kt)("inlineCode",{parentName:"p"},"import"),","),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import path from 'node:path'\n")),(0,a.kt)("h2",{id:"linked-plugins"},"Linked Plugins"),(0,a.kt)("p",null,"In version 2 of ",(0,a.kt)("inlineCode",{parentName:"p"},"@oclif/core")," linked plugins are transpiled at runtime using ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node"),". This is problematic for ESM plugins because ",(0,a.kt)("inlineCode",{parentName:"p"},"node")," depends on special ESM hooks being registered in the process in order to use ESM file paths. So in order for ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node")," to successfully transpile ESM plugins one of the two must be true:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"ts-node")," (with ESM enabled) is used to execute the CLI instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"node")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"node")," is used to execute the CLI with the ",(0,a.kt)("inlineCode",{parentName:"li"},"--loader=ts-node/esm")," option set. This can be done through ",(0,a.kt)("inlineCode",{parentName:"li"},"NODE_OPTIONS")," or exec args")),(0,a.kt)("p",null,"You likely don't want to depend on ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node")," being available on every machine your CLI is executed so that really only leaves the second option."),(0,a.kt)("p",null,"Practically speaking you have two options to support linked plugins:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Change the ",(0,a.kt)("inlineCode",{parentName:"li"},"node")," shebang at the top of ",(0,a.kt)("inlineCode",{parentName:"li"},"bin/run.js")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"bin/dev.js")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"#!/usr/bin/env -S node --loader ts-node/esm --no-warnings=ExperimentalWarning")),(0,a.kt)("li",{parentName:"ol"},"Ask users to set ",(0,a.kt)("inlineCode",{parentName:"li"},'NODE_OPTIONS="--loader=ts-node/esm"')," in their environment if they'd like for ESM plugins to transpile at runtime.")),(0,a.kt)("p",null,"Option #1 is viable but it's important to understand that it is still an experimental loader and could change at anytime. That being said, if the loader were to introduce a breaking change ",(0,a.kt)("em",{parentName:"p"},"it would only affect linked plugins"),". Installed plugins would still work the same since they do not depend on ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node")," to transpile the code at runtime. Please see ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/documentation.html#documentation_stability_index"},"node's stability index")," for more."),(0,a.kt)("p",null,"Also, if you choose to include the ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node/esm")," loader in the shebang, we recommend adding the following to your root plugin's tsconfig"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"ts-node": {\n  "scope": true\n}\n')),(0,a.kt)("p",null,"This will allow ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node")," to successfully register multiple projects without any interference from the root plugin's tsconfig settings."),(0,a.kt)("p",null,"Option #2 still leverages the experimental ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node/esm")," loader but by asking users to opt into it it distances your CLI from any breaking changes that might suddenly occur."),(0,a.kt)("p",null,"Regardless of which path you take to support linked plugins, oclif will fall back on the linked plugin's compiled source code if it can't transpile it at runtime. This means that your users can still use linked ESM plugins without setting ",(0,a.kt)("inlineCode",{parentName:"p"},'NODE_OPTIONS="--loader=ts-node/esm"')," in their environment ",(0,a.kt)("em",{parentName:"p"},"as long as they understand the plugin must be compiled first"),"."))}k.isMDXComponent=!0}}]);