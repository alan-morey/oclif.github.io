"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4059],{4836:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=a(4848),t=a(8453);const r={author:"Casey Watts and Jeff Dickey",title:"CLI Flags Explained"},o=void 0,l={permalink:"/blog/2019/02/20/cli-flags-explained",source:"@site/blog/2019-02-20-cli-flags-explained.md",title:"CLI Flags Explained",description:'oclif makes it easy to create a command line interface (CLI) in node. Most commands have parameters \u2014 also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.',date:"2019-02-20T00:00:00.000Z",formattedDate:"February 20, 2019",tags:[],readingTime:4.925,hasTruncateMarker:!1,authors:[{name:"Casey Watts and Jeff Dickey"}],frontMatter:{author:"Casey Watts and Jeff Dickey",title:"CLI Flags Explained"},unlisted:!1,prevItem:{title:"oclif's Current Node Support",permalink:"/blog/2019/10/31/oclif-node-updates"},nextItem:{title:"Introducing oclif",permalink:"/blog/2018/03/20/introducing-oclif"}},i={authorsImageUrls:[void 0]},d=[{value:"Parts of Speech",id:"parts-of-speech",level:2},{value:"Example <code>ls</code>",id:"example-ls",level:3},{value:"command",id:"command",level:4},{value:"argument",id:"argument",level:4},{value:"Long flag",id:"long-flag",level:4},{value:"Short flag",id:"short-flag",level:4},{value:"Flag arguments",id:"flag-arguments",level:4},{value:"Other Ways of Passing Data",id:"other-ways-of-passing-data",level:2},{value:"Designing a Command",id:"designing-a-command",level:2},{value:"argument",id:"argument-1",level:3},{value:"short flag with argument",id:"short-flag-with-argument",level:3},{value:"long flag with argument",id:"long-flag-with-argument",level:3},{value:"environment variable",id:"environment-variable",level:3},{value:"standard input",id:"standard-input",level:3},{value:"Command ergonomics",id:"command-ergonomics",level:2},{value:"Short flag vs long flag",id:"short-flag-vs-long-flag",level:3}];function c(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"oclif"})," makes it easy to create a command line interface (CLI) in node. Most commands have ",(0,s.jsx)(n.strong,{children:"parameters"}),' \u2014 also known as "flags", "args", and sometimes "options". This blog post explains what these parameters are and when to use them. We also have a new feature that makes it easier for users to detect typos when using parameters.']}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note the following describes GNU-style flags. Not all CLIs follow this convention, but it is the most commonly used."})}),"\n",(0,s.jsx)(n.h2,{id:"parts-of-speech",children:"Parts of Speech"}),"\n",(0,s.jsx)(n.p,{children:'Any command line interface command has a few standard "parts of speech".  As a user of CLI tools, knowing these parts of speech can help you make fewer typos. It can also help you understand complex commands other people share with you more quickly. If you are designing a CLI tool it is even more important to understand these parts of speech, so you can come up with the most ergonomic interface for your users.'}),"\n",(0,s.jsxs)(n.p,{children:["Of the many ways you can pass data to a CLI command, three of them are ",(0,s.jsx)(n.strong,{children:"parameters"}),' that are always to the "right" of the command. The three types of parameters are ',(0,s.jsx)(n.strong,{children:"argument"}),", ",(0,s.jsx)(n.strong,{children:"short flag"}),", and ",(0,s.jsx)(n.strong,{children:"long flag"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"example-ls",children:["Example ",(0,s.jsx)(n.code,{children:"ls"})]}),"\n",(0,s.jsxs)(n.p,{children:["One of the  most common and simplest unix commands is ",(0,s.jsx)(n.code,{children:"ls"}),' which "lists" the contents of a directory.']}),"\n",(0,s.jsx)(n.h4,{id:"command",children:"command"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ls\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This command ",(0,s.jsx)(n.code,{children:"ls"})," works on its own, as a standalone ",(0,s.jsx)(n.strong,{children:"command"}),". Without any parameters this command will list the contents of the current folder, using an implied ",(0,s.jsx)(n.code,{children:"."})," directory."]}),"\n",(0,s.jsx)(n.h4,{id:"argument",children:"argument"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ls .\nls ~/code/some-repo-name\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you pass a command ",(0,s.jsx)(n.strong,{children:"argument"})," to this command, like the directory name ",(0,s.jsx)(n.code,{children:"."})," (current folder) or ",(0,s.jsx)(n.code,{children:"~/code/some-repo-name"}),", it will list the contents of that directory instead."]}),"\n",(0,s.jsx)(n.p,{children:"An argument is anything to the right of a command that is not a flag. An argument can come before or after flags."}),"\n",(0,s.jsx)(n.h4,{id:"long-flag",children:"Long flag"}),"\n",(0,s.jsxs)(n.p,{children:["To list additional files that are normally hidden (like ",(0,s.jsx)(n.code,{children:"~/.bashrc"}),"), you can use a flag on the ",(0,s.jsx)(n.code,{children:"ls"})," command. ",(0,s.jsx)(n.code,{children:"ls --all"})," is the ",(0,s.jsx)(n.strong,{children:"long flag"})," form. A long flag always uses a double dash, and it is always represented by multiple characters."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ls --all\nls . --all\n"})}),"\n",(0,s.jsx)(n.h4,{id:"short-flag",children:"Short flag"}),"\n",(0,s.jsxs)(n.p,{children:["There is also a ",(0,s.jsx)(n.strong,{children:"short flag"})," form of this flag: ",(0,s.jsx)(n.code,{children:"ls -a"}),". The ",(0,s.jsx)(n.code,{children:"a"})," is short for ",(0,s.jsx)(n.code,{children:"all"})," in this case. A short flag always uses a single dash, and it is always represented by a single letter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ls -a\nls . -a\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Short flags can ",(0,s.jsx)(n.strong,{children:"stack"})," too, so you don't need a separate dash for each one. Order does not matter for these, unless passing a flag argument."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ls -la\n"})}),"\n",(0,s.jsx)(n.h4,{id:"flag-arguments",children:"Flag arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Many flags accept an ",(0,s.jsx)(n.strong,{children:"option"}),', which is a "flag argument" (as opposed to a "command argument"). In general a command\'s parameters can be in any order, but flags that accept options must have the option directly after the flag.']}),"\n",(0,s.jsxs)(n.p,{children:["For an example, here the ",(0,s.jsx)(n.code,{children:"-x"})," flag does not accept an option but the ",(0,s.jsx)(n.code,{children:"-f"})," flag does. ",(0,s.jsx)(n.code,{children:"archive.tar"})," is the option being passed to ",(0,s.jsx)(n.code,{children:"-f"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"tar -x -f archive.tar\ntar -xf archive.tar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A flag and its option can be separated by a space ",(0,s.jsx)(n.code,{children:" "})," or an equals sign ",(0,s.jsx)(n.code,{children:"="}),". Interestingly, short flags (but not long flags) can even skip the space, although many people find it much easier to read with the space or equals sign."]}),"\n",(0,s.jsx)(n.p,{children:"These three are all valid and equivalent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"tar -f archive.tar\ntar -f=archive.tar\ntar -farchive.tar\n"})}),"\n",(0,s.jsx)(n.p,{children:"Long flags must have a space or equals sign to separate the flag from its option."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"git log --pretty=oneline\ngit log --pretty oneline\n"})}),"\n",(0,s.jsx)(n.h2,{id:"other-ways-of-passing-data",children:"Other Ways of Passing Data"}),"\n",(0,s.jsxs)(n.p,{children:["We've covered ",(0,s.jsx)(n.strong,{children:"parameters"}),", which are ",(0,s.jsx)(n.strong,{children:"arguments"}),", ",(0,s.jsx)(n.strong,{children:"short flags"})," and ",(0,s.jsx)(n.strong,{children:"long flags"}),". There are two other ways to pass data to a command: ",(0,s.jsx)(n.strong,{children:"environment variables"}),' ("env vars"), or ',(0,s.jsx)(n.strong,{children:"standard input"}),' ("stdin"). These won\'t be covered in this blog post.']}),"\n",(0,s.jsx)(n.h2,{id:"designing-a-command",children:"Designing a Command"}),"\n",(0,s.jsx)(n.p,{children:'Scenario: we want to design an oclif command that echos an input like "Casey", and returns "hi, Casey!". There are many ways the user could pass this in, and here we show an example of each type of input.'}),"\n",(0,s.jsx)(n.h3,{id:"argument-1",children:"argument"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"greet-me Casey\n"})}),"\n",(0,s.jsx)(n.h3,{id:"short-flag-with-argument",children:"short flag with argument"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"greet-me -n Casey\ngreet-me -n=Casey\ngreet-me -nCasey\n"})}),"\n",(0,s.jsx)(n.h3,{id:"long-flag-with-argument",children:"long flag with argument"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"greet-me --name=Casey\ngreet-me --name Casey\n"})}),"\n",(0,s.jsx)(n.h3,{id:"environment-variable",children:"environment variable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"NAME=Casey greet-me\n"})}),"\n",(0,s.jsx)(n.h3,{id:"standard-input",children:"standard input"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'echo "Casey" | greet-me\n'})}),"\n",(0,s.jsx)(n.h2,{id:"command-ergonomics",children:"Command ergonomics"}),"\n",(0,s.jsx)(n.h3,{id:"short-flag-vs-long-flag",children:"Short flag vs long flag"}),"\n",(0,s.jsx)(n.p,{children:"Many CLI commands allow for both long flag and short flag forms. In the Heroku CLI every flag has at least a long flag form and roughly half of the flags also have a short flag form."}),"\n",(0,s.jsx)(n.p,{children:"The long flag form is easier to read, but takes more characters to type. It is often most useful when you want someone to understand a particular command statement quickly and easily, such as in a README."}),"\n",(0,s.jsx)(n.p,{children:"The short flag form is quicker to type, and is often better for frequently used commands. Short flags are especially useful when stacking short flags together."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>l});var s=a(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);